# -*- coding: utf-8 -*-
"""RK(1to8)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kGo5acUhVcf3DmBs3L5AsRhHGVY7_hiO
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy import integrate
from google.colab import files
from scipy.integrate import solve_ivp

def nonlinear1(t, y, a, b):
    """
    Calculates the derivative value for the differential equation.

    :param t: A float for the time variable
    :param y: A float for the dependent variable
    :param a: Parameter for the equation
    :param b: Parameter for the equation
    :return: dydt, a float for the derivative of the differential equation
    """
    # Calculate the derivative explicitly
    dydt = -a * y**3 + np.sin(b * t)
    return dydt

def main():
    """
    Main function to ensure code portability. The script will only execute when run directly.
    """
    # Define the initial variables
    y0 = np.array([0])  # Initial state at t = 0
    t0 = 0  # Initial time
    tf = 20  # Final time
    n = 101  # Number of points for output evaluation

    # Create a numpy array of n times linearly spaced between t0 and tf
    t = np.linspace(t0, tf, n)

    # Define different values for parameters a and b
    parameter_sets = [(1, 1), (2, 1), (2, 2), (3, 3)]  # (a, b) pairs
    labels = [f'a={a}, b={b}' for a, b in parameter_sets]  # Labels for the legend

    plt.figure(figsize=(10, 6))  # Create a figure for the plot

    # Loop through each set of parameters and solve the differential equation
    for (a, b), label in zip(parameter_sets, labels):
        result = integrate.solve_ivp(fun=lambda t, y: nonlinear1(t, y, a, b),  # Define the function with parameters
                                     t_span=(t0, tf),  # Initial and final times
                                     y0=y0,  # Initial state
                                     method="RK45",  # Integration method
                                     t_eval=t)  # Time points for result to be reported

        # Read the solution and time from the array returned by SciPy
        y = result.y[0]

        # Plot the solution
        plt.plot(t, y, label=label)  # Add label for the legend

    # Configure plot
    plt.xlabel('Time (t)')
    plt.ylabel('Dependent Variable (y)')
    plt.legend()  # Show legend
    plt.xlim(-0.1,20.1)
    plt.savefig('R1.png', bbox_inches='tight')

if __name__ == '__main__':
    main()

plt.show()  # Display the plot
#files.download('R1.png')

def differential_rl(v, r, l, i):
    """
    Calculates the change in current over time from the formula
    L(dI/dt) = V - RI
    :param v: Float for voltage
    :param r: Float for resistance (Ohms)
    :param l: Float for inductance (Henries)
    :param i: Float for current (Amps)
    :return: Float representing dI/dt
    """
    return (v - r * i) / l

def exact_solution_rl(v, r, l, t):
    """
    Calculates the exact solution for current over time.
    I(t) = (V/R)(1 - exp(-Rt/L))
    :param v: Float for voltage
    :param r: Float for resistance (Ohms)
    :param l: Float for inductance (Henries)
    :param t: Float for time (seconds)
    :return: Float representing the exact current at time t
    """
    return (v / r) * (1 - np.exp(-r * t / l))

def main():
    # Define parameters
    V = 10  # Voltage (V)
    R = 50 # Resistance (Ohms)
    L = 100  # Inductance (H)
    I0 = 0  # Initial current (A)
    t0 = 0 # Initial time (s)
    tf = 10  # Final time (s)

    # Define different time step sizes (h)
    h_values = [3, 2, 1, 0.5]  # Different time step sizes
    colors = ['purple', 'g', 'r', 'b']  # Different colors for each h value

    plt.figure(figsize=(12, 8))  # Set figure size for better visibility

    for idx, h in enumerate(h_values):
        n = int(tf / h) + 1  # Calculate the number of points based on h
        t = np.linspace(t0, tf, n)  # Create time array

        # Solve the differential equation using integrate.solve_ivp
        result = integrate.solve_ivp(
            fun=lambda t, i: differential_rl(V, R, L, i),
            t_span=(t0, tf),
            y0=[I0],
            method='RK45',
            t_eval=t
        )

        # Read the solution
        current_numeric = result.y[0]
        t_numeric = result.t

        # Calculate the exact solution
        current_exact = exact_solution_rl(V, R, L, t_numeric)

        # Plotting results for each time step with different colors
        plt.plot(t_numeric, current_numeric, 'o', color=colors[idx], label=f'Numerical (h={h})')
        plt.plot(t_numeric, current_exact, '-', color=colors[idx], label=f'Exact (h={h})', alpha=0.5)

    plt.xlabel('Time (s)')
    plt.ylabel('Current (A)')
    plt.legend()
    plt.savefig('R2.png', bbox_inches='tight')
    plt.tight_layout()
    plt.show()

if __name__ == '__main__':
    main()
files.download('R2.png')

def differential_rl(v, r, l, i):
    """
    Calculates the change in current over time from the formula
    L(dI/dt) = V - RI.

    :param v: Float for voltage (V)
    :param r: Float for resistance (R)
    :param l: Float for inductance (L)
    :param i: Float for current (I)
    :return: Float for the change in current (dI/dt)
    """
    di_dt = (v - r * i) / l
    return di_dt

def exact_solution_rl(v, r, l, t):
    """
    Calculates the exact current over time for an RL circuit using the formula
    I = (V/R)(1-exp(-Rt/L)).

    :param v: Float for voltage (V)
    :param r: Float for resistance (R)
    :param l: Float for inductance (L)
    :param t: Float for time (t)
    :return: Float for the exact current at time t
    """
    i_exact = (v / r) * (1 - np.exp(-r * t / l))
    return i_exact

k = 1.0  # Spring constant (N/m)
m = 1.0  # Mass (kg)
omega = np.sqrt(k / m)  # Angular frequency (rad/s)

# Time array
t = np.linspace(0, 35, 1000)  # Time values

# Exact solutions for x(t) and v(t) based on SHO for x(0) = 0 and v(0) = 1
x = np.sin(omega * t)
v = np.cos(omega * t)

# Create subplots for time-dependency and phase space
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))

# Plot time dependency of x and v
ax1.plot(t, x, label="x(t)")
ax1.plot(t, v, label="v(t)")
ax1.set_xlabel("Time (t)")
ax1.set_ylabel("x(t), v(t)")
ax1.set_title("Time-Dependency of x and v (SHO)")
ax1.legend()

# Plot phase space (v against x)
ax2.plot(x, v, 'k')
ax2.set_xlabel(r"$x$")
ax2.set_ylabel(r"$v$")
ax2.set_title("Phase Space Plot (v vs x)")
ax2.axis('equal')

# Tight layout to prevent overlap
plt.tight_layout()

# Save the plot to a file
plt.savefig('R3.png', bbox_inches='tight')

# Show the plot
plt.show()
files.download('R3.png')

def damped_pendulum(t, y, b, omega0):
    x, v = y
    dxdt = v
    dvdt = -b * v - (omega0**2) * x
    return [dxdt, dvdt]

# Initial conditions
y0 = [1.0, 0.0]  # Initial position and velocity

# Time span and evaluation points
t_span = (0, 35)
t_eval = np.linspace(0, 35, 1000)

# Natural frequency
omega0 = 1.0

# Overdamped case (b > 2 * omega0)
b_overdamped = 3.0  # Adjust this value as needed

# Solve for the overdamped case
sol_overdamped = solve_ivp(damped_pendulum, t_span, y0, args=(b_overdamped, omega0), t_eval=t_eval)
x_overdamped, v_overdamped = sol_overdamped.y

# Plot time dependency and phase space for overdamped case
fig, axs = plt.subplots(1, 2, figsize=(12, 5))

# Time dependency
axs[0].plot(t_eval, x_overdamped, label="x(t)", color='blue')
axs[0].plot(t_eval, v_overdamped, label="v(t)", color='red')
axs[0].set_title("Overdamped Motion")
axs[0].set_xlabel("Time (t)")
axs[0].set_ylabel("Position (x) and Velocity (v)")
axs[0].legend()

# Phase space
axs[1].plot(x_overdamped, v_overdamped, 'k')
axs[1].set_title("Overdamped Phase Space")
axs[1].set_xlabel("Position (x)")
axs[1].set_ylabel("Velocity (v)")
axs[1].axis('equal')

# Show plot
plt.savefig('R3over.png', bbox_inches='tight')
plt.tight_layout()
plt.show()

files.download('R3over.png')

def damped_oscillator(t, y, b, omega0):
    """
    Calculates the derivatives for the damped harmonic oscillator.

    :param t: A float for the time variable
    :param y: A float array for the dependent variables [position, velocity]
    :param b: Damping coefficient
    :param omega0: Natural frequency
    :return: dydt, an array containing the derivatives [dx/dt, dv/dt]
    """
    x, v = y
    dydt = [v, -b * v - omega0**2 * x]
    return dydt

def main():
    b = 0.1  # Damping coefficient
    omega0 = 1.0  # Natural frequency
    y0 = [1.0, 0.0]  # Initial conditions: [initial position, initial velocity]
    t0 = 0  # Initial time
    tf = 50  # Final time
    n = 1000  # Number of points for output evaluation

    t = np.linspace(t0, tf, n)

    # Solve the ODE using solve_ivp
    result = integrate.solve_ivp(fun=lambda t, y: damped_oscillator(t, y, b, omega0),
                                  t_span=(t0, tf),
                                  y0=y0,
                                  method="RK45",
                                  t_eval=t)

    # Extract position and velocity
    position = result.y[0]
    velocity = result.y[1]

    # Create subplots for time dependency and phase space, side by side
    fig, axs = plt.subplots(1, 2, figsize=(12, 6))

    # Time dependency plot
    axs[0].plot(t, position, label='x(t)', color='b')
    axs[0].plot(t, velocity, label='v(t)', color='r')
    axs[0].set_xlabel('Time (s)')
    axs[0].set_ylabel('x(t),v(t)')
    axs[0].legend()

    # Phase space plot
    axs[1].plot(position, velocity, color='black')
    axs[1].set_title('Phase Space of Damped Oscillator')
    axs[1].set_xlabel('Position (x)')
    axs[1].set_ylabel('Velocity (v)')

    # Adjust layout
    plt.tight_layout()

    # Save the plot
    plt.savefig('R4.png', bbox_inches='tight')
    plt.show()

if __name__ == '__main__':
    main()
files.download('R4.png')

import numpy as np
import matplotlib.pyplot as plt
from scipy import integrate

# Placeholder function to simulate a damped pendulum ODE
def damped_pendulum(t, y, b, omega0):
    """
    ODE function for a damped pendulum.
    y[0] = position (x), y[1] = velocity (v)
    Returns the derivatives dx/dt and dv/dt.
    """
    x, v = y  # Position and velocity
    dxdt = v
    dvdt = -b * v - omega0**2 * x
    return [dxdt, dvdt]

# Placeholder variables
t0, tf, y0 = 0, 10, [1.0, 0.0]  # initial time, final time, initial condition (x0, v0)
t = np.linspace(t0, tf, 1000)  # Time points for result to be evaluated at

# Set the damping coefficient and resonant frequency
b = 0.5  # Damping coefficient
omega0 = 1.0  # Resonant frequency

# Define the lambda function that passes the parameters to the damped_pendulum function
lfun = lambda t, y: damped_pendulum(t, y, b, omega0)

# Use solve_ivp with the lambda function to solve the ODE
result = integrate.solve_ivp(fun=lfun,  # The lambda function
                             t_span=(t0, tf),  # Initial and final time
                             y0=y0,  # Initial state (position and velocity)
                             method="RK45",  # Integration method
                             t_eval=t)  # Time points for result

# Extract the solution (position and velocity) from the result
x = result.y[0]
v = result.y[1]

# Plot position and velocity versus time
plt.figure(figsize=(10, 6))
plt.plot(t, x, label='Position (x)')
plt.plot(t, v, label='Velocity (v)')
plt.title("Damped Pendulum: Position and Velocity over Time")
plt.xlabel("Time (t)")
plt.ylabel("Position (x) / Velocity (v)")
plt.legend()
plt.grid(True)
plt.show()

# Phase plot: Velocity vs Position
plt.figure(figsize=(6, 6))
plt.plot(x, v)
plt.title("Phase Plot: Velocity vs Position")
plt.xlabel("Position (x)")
plt.ylabel("Velocity (v)")
plt.grid(True)
plt.show()

a = 2  # Amplitude of the driving force
b = 0.2  # Damping coefficient
omega_0 = 2  # Natural frequency

def driven_pendulum(t, y, b, a, omega_d):
    """
    Calculates the derivatives for the driven damped harmonic oscillator.

    :param t: A float for the time variable
    :param y: A list or array of the dependent variables [x, v]
    :param b: Damping coefficient
    :param a: Amplitude of the driving force
    :param omega_d: Driving frequency
    :return: dydt, a list for the derivatives [dx/dt, dv/dt]
    """
    x, v = y
    dydt = [v, -b * v - omega_0**2 * x - a * np.sin(omega_d * t)]
    return dydt

def main():
    # Define the initial conditions
    y0 = [0, 0]  # Initial state [x(0), v(0)]
    t0 = 0  # Initial time
    tf = 50  # Final time
    n = 1000  # Number of points for output evaluation
    t = np.linspace(t0, tf, n)

    # Define different driving frequencies
    driving_frequencies = [2, 1.75, 1]
    amplitudes = []

    plt.figure(figsize=(12, 8))

    # Loop through each driving frequency
    for omega_d in driving_frequencies:
        result = integrate.solve_ivp(
            fun=lambda t, y: driven_pendulum(t, y, b, a, omega_d),
            t_span=(t0, tf),
            y0=y0,
            method="RK45",
            t_eval=t
        )

        # Read the solution and time
        x = result.y[0]
        plt.plot(t, x, label=f'x(t): $\omega_d = {omega_d}$')

        # Store amplitude for later analysis
        amplitude = np.max(np.abs(x))
        amplitudes.append(amplitude)

    # Configure plot
    plt.xlabel('Time (s)')
    plt.ylabel('Displacement (x)')
    plt.legend()
    plt.xlim(-0.2,50.2)
    plt.savefig('R6.png', bbox_inches='tight')
    plt.show()

    # Print out the measured amplitudes
    for omega_d, amplitude in zip(driving_frequencies, amplitudes):
        print(f'Driving Frequency: {omega_d}, Steady-State Amplitude: {amplitude}')

if __name__ == '__main__':
    main()
files.download('R6.png')

def driven_pendulum(t, y, b, omega_0, omega_d):
    """
    Defines the system of ODEs for the damped, driven harmonic oscillator.
    dx/dt = v
    dv/dt = -b*v - omega_0^2 * x + a * sin(omega_d * t)

    :param t: time
    :param y: [x, v], the position and velocity of the oscillator
    :param b: damping coefficient
    :param omega_0: natural frequency
    :param omega_d: driving frequency
    :return: [dx/dt, dv/dt]
    """
    x, v = y
    a = 1.5  # Amplitude of the driving force
    dydt = [v, -b * v - omega_0**2 * x + a * np.sin(omega_d * t)]
    return dydt

def calculate_amplitudes(tf, n, omega_0, b, y0):
    """
    Calculate the amplitude of the oscillation as a function of driving frequency.
    The transient behavior is ignored by only focusing on the last 20% of the simulation time.

    :param tf: Final time of the simulation
    :param n: Number of points for the time array
    :param omega_0: Natural frequency of the oscillator
    :param b: Damping coefficient
    :param y0: Initial conditions [x(0), v(0)]
    :return: None (generates a plot of amplitude vs driving frequency)
    """
    amplitudes = []  # Create empty list to store amplitudes
    t = np.linspace(0.8 * tf, tf, n)  # Time array for the last 20% of the simulation

    driving_freqs = np.linspace(0, 2 * omega_0, 100)  # Driving frequency range (20% to 200% of omega_0)

    # Loop through driving frequencies
    for omega_d in driving_freqs:
        # Define the lambda function for the ODE solver, passing in the current driving frequency
        lfun = lambda t, y: driven_pendulum(t, y, b, omega_0, omega_d)

        # Solve the differential equations
        result = integrate.solve_ivp(fun=lfun,
                                     t_span=(0, tf),
                                     y0=y0,
                                     method="RK45",
                                     t_eval=t)

        # Extract the position (x) from the results
        x = result.y[0]

        # Compute the peak-to-peak amplitude for the steady-state oscillation
        amplitude = (max(x) - min(x)) / 2
        amplitudes.append(amplitude)

    # Plot the resonance curve (amplitude vs driving frequency)
    plt.figure(figsize=(8, 6))
    plt.plot(driving_freqs, amplitudes, label=f'Damping: b = {b}', color='purple')
    plt.xlabel('Driving Frequency (rad/s)')
    plt.ylabel('Amplitude (m)')
    plt.ylim(-0.05,7)
    plt.xlim(-0.05,3.05)
    plt.savefig('R7.png', bbox_inches='tight')
    plt.show()

def main():
    """
    Main function to run the resonance curve analysis for a damped, driven harmonic oscillator.
    """
    # Define initial conditions and parameters
    y0 = [0, 0]  # Initial position and velocity [x(0), v(0)]
    omega_0 = 1.5  # Natural frequency (rad/s)
    b = 0.15  # Damping coefficient
    tf = 100  # Final time for the simulation
    n = 1000  # Number of points in time array

    # Calculate and plot the amplitude vs driving frequency
    calculate_amplitudes(tf, n, omega_0, b, y0)

if __name__ == '__main__':
    main()
#files.download('R7.png')

def driven_pendulum(t, y, b, omega_0, omega_d, A):
    x, v = y
    dxdt = v
    dvdt = -b*v - omega_0**2 * x + A * np.sin(omega_d * t)  # Driving force with amplitude A
    return [dxdt, dvdt]

def resonance_curves(tf, n, omega_0, y0, b_values, A):
    t = np.linspace(0.8*tf, tf, n)  # Time array for steady-state portion
    driving_freq = np.linspace(0, 2*omega_0, 100)  # Driving frequencies (20% to 200% of natural frequency)

    plt.figure(figsize=(10, 6))

    for b in b_values:
        amplitudes = []
        for omega_d in driving_freq:
            lfun = lambda t, y: driven_pendulum(t, y, b, omega_0, omega_d, A)
            result = integrate.solve_ivp(fun=lfun, t_span=(0, tf), y0=y0, method="RK45", t_eval=t)

            x = result.y[0]  # Extract position (x)
            amplitude = (max(x) - min(x)) / 2  # Peak-to-peak amplitude
            amplitudes.append(amplitude)

        # Plot the resonance curve for each damping coefficient
        plt.plot(driving_freq, amplitudes, label=f'b = {b}')

    plt.xlabel('Driving Frequency (rad/s)')
    plt.ylabel('Amplitude (m)')
    plt.legend()
    plt.ylim(-0.05,10)
    plt.xlim(-0.05,3.05)
    plt.savefig('R8.png', bbox_inches='tight')
    plt.show()

# Initial conditions
y0 = [0, 0]  # Starting position and velocity
tf = 100  # Total time
n = 500  # Number of time steps
omega_0 = 1.5  # Natural frequency
b_values = [0.1, 0.15, 0.3, 0.6, 0.9]  # Damping coefficients to investigate
A = 1.5  # Driving force amplitude

# Call the function to plot resonance curves
resonance_curves(tf, n, omega_0, y0, b_values, A)
files.download('R8.png')