# -*- coding: utf-8 -*-
"""E4

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IdKSRbG4xfTJqnSy6RrVW2hatf404nYj
"""

import numpy as np
import matplotlib.pyplot as plt
from google.colab import files

def exact_solution(t):
    x_exact = np.sin(t)
    v_exact = np.cos(t)
    return x_exact, v_exact

# Define the modified Euler method
def improved_euler_sho(h, tmax, x0, v0):
    t_values = np.arange(0, tmax, h)
    x_values = np.zeros_like(t_values)
    v_values = np.zeros_like(t_values)

    # Set initial conditions
    x_values[0] = x0
    v_values[0] = v0

    # Loop over time steps
    for i in range(len(t_values) - 1):
        t = t_values[i]
        x_init = x_values[i] + h * v_values[i]
        v_init = v_values[i] - h * x_values[i]

        x_values[i + 1] = x_values[i] + 0.5 * h * (v_values[i] + v_init)
        v_values[i + 1] = v_values[i] - 0.5 * h * (x_values[i] + x_init)

    return t_values, x_values, v_values

# Parameters
tmax = 32  # Maximum time
x0 = 0     # Initial position
v0 = 1     # Initial velocity
h_values = [0.05, 0.025, 0.005, 0.0005]  # Step sizes to test divergence

# Plot solutions for different step sizes
plt.figure(figsize=(10, 6))

for h in h_values:
    t_vals, x_vals, v_vals = improved_euler_sho(h, tmax, x0, v0)
    plt.plot(t_vals, x_vals, label=f'Numerical x, h={h}')

# Exact solution for comparison
t_exact = np.linspace(0, tmax, 1000)
x_exact, v_exact = exact_solution(t_exact)
plt.plot(t_exact, x_exact, 'k--', label='Exact x = sin(t)')

# Plot configuration
plt.xlim(-0.1,31.5)
plt.xlabel('Time (t)')
plt.ylabel('Position (x)')
plt.legend()
plt.savefig('E4.png', bbox_inches='tight')
plt.show()
#files.download('E4.png')

def exact_solution(t):
    return np.sin(t)

# Improved Euler method for the system of equations
def improved_euler_method_sho(h, tmax, x0, v0):
    t_values = np.arange(0, tmax, h)
    x_values = np.zeros_like(t_values)
    v_values = np.zeros_like(t_values)

    # Initial conditions
    x_values[0] = x0
    v_values[0] = v0

    # Improved Euler integration loop
    for i in range(len(t_values) - 1):
        # Predictor step
        x_init = x_values[i] + h * v_values[i]
        v_init = v_values[i] - h * x_values[i]

        # Corrector step
        x_values[i + 1] = x_values[i] + 0.5 * h * (v_values[i] + v_init)
        v_values[i + 1] = v_values[i] - 0.5 * h * (x_values[i] + x_init)

    return t_values, x_values

# Parameters
tmax = 10 * np.pi  # To cover 5 cycles of sin(t)
x0 = 0             # Initial position (x = 0)
v0 = 1             # Initial velocity (v = 1)
h_values = [0.05, 0.025, 0.005, 0.0005]  # Time steps for testing

# Plot solutions for different time steps
plt.figure(figsize=(10, 6))

for h in h_values:
    t_vals, x_vals = improved_euler_method_sho(h, tmax, x0, v0)

    # Exact solution
    x_exact = exact_solution(t_vals)

    # Calculate the error
    error = np.abs(x_vals - x_exact)

    # Plot the error
    plt.plot(t_vals, error, label=f'Diff, h={h}')

# Plot configuration
plt.savefig('E4diff.png')
plt.xlabel('Time (t)')
plt.ylabel('Difference')
plt.xlim(-0.2,31.5)
#plt.ylim(-0.0001,0.007)
plt.yscale('log')
plt.legend()
plt.savefig('E4diff.png', bbox_inches='tight')
plt.show()
#files.download('E4diff.png')

def exact_solution(t):
    return np.sin(t)

# Simple Euler method for the system of equations
def euler_method_sho(h, tmax, x0, v0):
    t_values = np.arange(0, tmax, h)
    x_values = np.zeros_like(t_values)
    v_values = np.zeros_like(t_values)

    # Initial conditions
    x_values[0] = x0
    v_values[0] = v0

    # Euler integration loop
    for i in range(len(t_values) - 1):
        x_values[i + 1] = x_values[i] + h * v_values[i]   # dx/dt = v
        v_values[i + 1] = v_values[i] - h * x_values[i]   # dv/dt = -x

    return t_values, x_values

# Improved Euler method for the system of equations
def improved_euler_method_sho(h, tmax, x0, v0):
    t_values = np.arange(0, tmax, h)
    x_values = np.zeros_like(t_values)
    v_values = np.zeros_like(t_values)

    # Initial conditions
    x_values[0] = x0
    v_values[0] = v0

    # Improved Euler integration loop
    for i in range(len(t_values) - 1):
        # Predictor step
        x_init = x_values[i] + h * v_values[i]
        v_init = v_values[i] - h * x_values[i]

        # Corrector step
        x_values[i + 1] = x_values[i] + 0.5 * h * (v_values[i] + v_init)
        v_values[i + 1] = v_values[i] - 0.5 * h * (x_values[i] + x_init)

    return t_values, x_values

# Parameters
tmax = 10 * np.pi  # To cover 5 cycles of sin(t)
x0 = 0             # Initial position (x = 0)
v0 = 1             # Initial velocity (v = 1)
h = 0.01           # Time step for testing

# Run both methods
t_vals_euler, x_vals_euler = euler_method_sho(h, tmax, x0, v0)
t_vals_improved, x_vals_improved = improved_euler_method_sho(h, tmax, x0, v0)

# Exact solution
x_exact = exact_solution(t_vals_euler)

# Calculate the errors
error_euler = np.abs(x_vals_euler - x_exact)
error_improved = np.abs(x_vals_improved - x_exact)

# Plotting the errors
plt.figure(figsize=(10, 6))

plt.plot(t_vals_euler, error_euler, label='Simple Euler Method', color='red')
plt.plot(t_vals_improved, error_improved, label='Improved Euler Method', color='blue')

# Plot configuration
plt.xlabel('Time (t)')
plt.ylabel('Difference')
plt.yscale('log')  # Log scale to visualize small errors
plt.legend()
plt.savefig('E4final.png')
plt.show()
#files.download('E4final.png')

def exact_solution(t):
    return np.sin(t)  # Exact position as a function of time

# Simple Euler method for the system of equations
def simple_euler_method_sho(h, tmax, x0, v0):
    t_values = np.arange(0, tmax, h)  # Time array
    x_values = np.zeros_like(t_values)  # Position array
    v_values = np.zeros_like(t_values)  # Velocity array

    # Set initial conditions
    x_values[0] = x0
    v_values[0] = v0

    # Simple Euler integration loop
    for i in range(len(t_values) - 1):
        x_values[i + 1] = x_values[i] + h * v_values[i]
        v_values[i + 1] = v_values[i] - h * x_values[i]

    return t_values, x_values

# Improved Euler method for the system of equations
def improved_euler_method_sho(h, tmax, x0, v0):
    t_values = np.arange(0, tmax, h)  # Time array
    x_values = np.zeros_like(t_values)  # Position array
    v_values = np.zeros_like(t_values)  # Velocity array

    # Set initial conditions
    x_values[0] = x0
    v_values[0] = v0

    # Improved Euler integration loop
    for i in range(len(t_values) - 1):
        # Predictor step
        x_init = x_values[i] + h * v_values[i]
        v_init = v_values[i] - h * x_values[i]

        # Corrector step
        x_values[i + 1] = x_values[i] + 0.5 * h * (v_values[i] + v_init)
        v_values[i + 1] = v_values[i] - 0.5 * h * (x_values[i] + x_init)

    return t_values, x_values

# Parameters
tmax = 32  # Maximum time to cover several cycles
x0 = 0     # Initial position
v0 = 1     # Initial velocity
h = 0.0005   # Fixed time step

# Run the Simple Euler Method
t_vals_simple, x_vals_simple = simple_euler_method_sho(h, tmax, x0, v0)

# Run the Improved Euler Method
t_vals_improved, x_vals_improved = improved_euler_method_sho(h, tmax, x0, v0)

# Exact solution for comparison
t_exact = np.arange(0, tmax, 0.001)  # Fine time array for exact solution
x_exact = exact_solution(t_exact)

# Calculate absolute differences
difference_simple = np.abs(x_vals_simple - exact_solution(t_vals_simple))
difference_improved = np.abs(x_vals_improved - exact_solution(t_vals_improved))

# Plotting
plt.figure(figsize=(10, 6))

# Plot differences
plt.plot(t_vals_simple, difference_simple, label='Simple Euler Method', color='r')
plt.plot(t_vals_improved, difference_improved, label='Improved Euler Method', color='b')
plt.xlim(-0.2, 32.1)
plt.yscale('log')
plt.xlabel('Time (t)')
plt.ylabel('Difference')
plt.legend()

# Show plots
plt.tight_layout()
plt.savefig('E4comp', bbox_inches='tight')
plt.show()
#files.download('E4comp.png')